Name of language:
	Cinroll after "Cinnamon Roll"
	Could have a backronym like "Common Imperative Notation for RAM Operations in a high-Leveled Language"

General:
	Unicode support
	Unlimited length on user-defined symbols
	Memory model flexibility. The language should not enforce
	Standard library typenames begin with capital letter
	Some easy way of defining associative binary operators (and non-associative too)
	Lazy evaluation of function arguments. Should be defined in the function declaration (Alias of function type? Make it like D lang? Will this be confusing or convenient?)
	Labeling loops and break out of labeled loops specifically or by index
	self[FUNCTION] in function scope returns the function itself
	Workspaces using "."
	"local" keyword for symbols. Like "static" in C/C++ and "sealed" in Scala but can be used as "local[WORKSPACE]", "local[FILE]", "local[COMPILATION_UNIT]" explicitly
	"import" imports a file and uses the root workspace by default. "import[WORKSPACE]" uses the local workspace

Data:
	Everything that resides in runtime is data. Functions, constants, variables.
	All data have a Pointer referencing method:
		def ref(data[T] variable):Pointer[T];

Functions:
	One input, one output
	Function overloading from the given arguments
	Unicode function names
	Syntax:
		def functionName(Int arg) -> Int = arg+1;

		def result:Int = functionName(5);
	or in lambda form:
		def functionName = (Int arg) -> arg+1
		def functionName = (Int arg) -> Int{arg+1}
	or (The difference is that `out` must be allocated and therefore doesn't need to allocate a return value in beforehand) (Or should they be equivalent and ban expressions from being used as statements?):
		def functionName(Int arg) => (Pointer[Int] out){
			out = arg+1;
		}

		def result:Int;
		functionName(5) => (result);
	Difference between closure and function. Normal functions don't capture scope definitions.

Function declaration:
	def functionName(Int,String):Int;
	def functionName(a,b) = a + strlen(b);

	The function declaration makes the parameter and return types known for the implementation.
	Unlike variable declarations, these are not allocating data.

Constants (Immutable values, can be treated as lvalues):
	def a = 5;
	def a:Int = 5;

Variables (Mutable values):
	def a:Var = 5;
	def a:Var[Int] = 5;

	The type "Var[T]" has a "=" method defined that can modifiy its value, but the new must stay as T.
	Variables have an implicit conversion for values:
		implicit def val(Var[T] variable):T;

Tuples/structures/argument lists are multiple values together:
	(Int,Int) tuple = (2,4);
	(Int a,Int b) namedTuple = (2,4);
	`,` is the tuple join function as in "(1,2)"
	(A,B,C) = (A,(B,C)) = ((A,B),C). This is not functioning like in C where alignment and padding may be appliced and the size of (A,B,A,B) may not neccesarily be equivalent to ((A,B),(A,B)). This makes it nessecary to include a "realsizeof" and "usedsizeof" where the used size indicates the total allocated space without the alignment at the beginning and the padding at the end.

Pointer types:
	The type definition is as following:
		Pointer[Int]
	and has a dereference method defined with the type:
		def deref(Pointer[T] ptr):T;
	Mutable pointer to mutable integer:
		Var[Pointer[Var[Int]]]
	Nullable pointer:
		(Pointer[Int] | Null)

Types:
	Type aliases: (A is another way of saying B)
		type A = B
		type A = [B]
	Hidden type alias: (A behaves like B datawise, but cannot be used in place of B. B can be used in place of A)
		type A => B
	Structure/record:
		type A = [B,C]
	Bottom type for error handling
	Non-builtin/implemented tagged union types. Makes it possible for a "Option" type to be implemented:
		type A = TaggedUnion[B,C,D,E]
	Builtin union types. Makes it possible for a "TaggedUnion" type to be implemented:
		type A = [B|C|D|E]
	Int with specific size: "Int[64]", "Int[32]"
	Fastest smallest sized "Int.Fastest[8]", at least of size "Int.Least[32]" using type aliases to the specific sized ints
	Types of types:
		Abstract types:
			Describes a functionality
			Can inherit other abstract types, requiring them for its own functionality.
		Data types:
			Describes data. Like tuples (data grouped together) or raw numbers, arrays and so forth.
			Can inherit other data types' functionalities if the sizes is equal or larger in size (Union type).
			Can satisfy abstract types' constraints and make use of their functionality.
	Type parameters:

Inlining/static compiling:
	Behaves like a normal function but force inlines it: (Inlined functions will have some restrictions)
		inline def functionName(Int i) -> Int = i+1
	or (Inlined constants/variables)
		inline def callFunctionName:Int = functionName(5)
	Preprocessor replacements: (They shouldn't be needed?)
	(All pure or inlined string functions should work for symbol. The "symbol" type should be an alias of "String" for the compiler)
		inline def if2(symbol i) -> symbol = "if(" ++ i ++ ")"

Memory management:
	Manual memory management with a heap (malloc and free) and a stack (based on scope).
	`malloc` is defined as:
		def malloc(size size) -> heapPointer;
	"HeapPointer" is a child type of "Pointer"

Runtime types:

Namespaces, static namespaces and exported namespaces
